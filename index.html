<!DOCTYPE html>

<style>  @import url("CSS/style.css");</style>
<html>
  <body>
    <ul>
      <li> <a href="#array"> std::array </a> </li>
      <li> <a href="#vector"> std::vector </a> </li>
      <li> <a href="#forwardlist"> std::forwardlist </a> </li>
      <li> <a href="#list"> std::list </a> </li>
      <li> <a href="#stack"> std::stack </a> </li>
      <li> <a href="#queue"> std::queue </a> </li>
      <li> <a href="#deque"> std::deque </a> </li>
      <li> <a href="#priority_queue"> std::priority_queue </a> </li>
      <li> <a href="#set"> std::set </a> </li>
      <li> <a href="#multi_set"> std::multi_set </a> </li>
      <li> <a href="#unordered_set"> std::unordered_set </a> </li>
      <li> <a href="#map"> std::map </a> </li>
      <li> <a href="#multimap"> std::multimap </a> </li>
      <li> <a href="#unordered_map"> std::unordered_map </a> </li>
    <li> <a href="#unordered_multimap"> std::unordered_multimap </a> </li>
    </ul>
   
    
    <!-- Array -->
    <h1> <a name="array"> </a><h1> std::array </h1>
    <ul>
      <li> Array elements of same type are stored contiguously in memory </li>
      <li> Std::array satisfies the requirements of container except </li>
        <ul> 
          <li> The size of the array should be static i.e. default constructor without the size is not allowed </li>
          <li> Unlike other containers, complexity of swapping two arrays is linear as this operation involves copying each element separately</li>
        </ul>
      </li>
    </ul>
    
    <table>
      <!--Head of the table -->
      <thead> 
        <tr> 
          <th scope="col"> Type </th> 
          <th scope="col"> Format </th>
          <th scope="col"> Description </th> 
          <th scope="col"> Complexity </th> 
        </tr> 
      </thead>
      <tbody>
        <!--Constructors -->
        <tr> 
          <th rowspan=1 scope="row"> Constructors </th> 
          <td> array&ltT,n&gt a</td> 
          <td> Create an array, a, of type T with n elements</td> 
          <td> O(1)</td>
        </tr>
        
        <!--Iterators -->
        <tr> 
          <th rowspan=8 scope="row"> Iterators </th> 
          <td> a.begin()</td> 
          <td> Return iterator to beginning of the array</td> 
          <td> O(1)</td>
        </tr>
        <tr> 
          <td> a.end()</td> 
          <td> Return iterator to end of the array</td>	
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.rbegin()</td> 
          <td> Returns reverse iterator to reverse beginning (i.e. end) of the array</td> 
          <td> O(1)</td>
        </tr>
        <tr> 
          <td> a.rend()</td> 
          <td> Return reverse iterator to reverse end (i.e. beginning) of the array</td> 
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.cbegin()</td> 
          <td> Return constant iterator to beginning of the array</td> 
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.cend()</td> 
          <td> Return constant iterator to end of the array</td> 
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.crbegin()</td> 
          <td> Return reverse constant iterator to reverse beginning of the array</td> 
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.crend()</td> 
          <td> Return reverse constant iterator to reverse end of the array</td> 
          <td>O(1)</td> 
        </tr>
        
        <!--Capacity -->
        <tr> 
          <th rowspan=3 scope="row"> Capacity</th> 
          <td> a.size()</td> 
          <td> Return the size of the array (number of elements)</td> 
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.max_size()</td> 
          <td> Return the size of the array (number of elements, same as a.size())</td> 
          <td> O(1)</td> 
        </tr>
        <tr> 
          <td> a.empty()</td> 
          <td> Test whether the array is empty are not</td> 
          <td>O(1)</td> 
        </tr>
        
        <!--Accessing elements -->
        <tr> 
          <th rowspan=5 scope="row"> Element Access</th> 
          <td> a[i]</td> 
          <td> Access the i<sup>th</sup> element of the array</td> 
          <td> O(n)</td> 
        </tr>
        <tr> 
          <td> a.at(i)</td> 
          <td> Access the i<sup>th</sup> element of the array (automatically checks the bounds of the array)</td> 
          <td>O(1)</td> 
        </tr>
        <tr> 
          <td> a.front()</td> 
          <td> Access the first element of the array</td> 
          <td> O(1)</td> </tr>
        <tr> 
          <td> a.back()</td> 
          <td> Access the last element of the array</td> 
          <td> O(1)</td> </tr>
        <tr> 
          <td> a.data()</td> 
          <td> Return pointer to the first element of the array</td> 
          <td> O(1)</td> 
        </tr>
        
        <!--Modifiers -->
        <tr> 
          <th rowspan=2 scope="row"> Modifiers</th> 
          <td> a.fill(value)</td> 
          <td> Fill the array with a specified value</td> 
          <td> O(n)</td> 
        </tr>
        <tr> 
          <td> a.swap(array<T>)</td> 
          <td> Swap the content of two arrays</td> 
          <td> O(n)</td> 
        </tr>
      </tbody> <!--End of the body -->
    </table> <!--End of the table -->
    
    <!-- Vector -->
    <h1> <a name="vector"> </a> std::vector </h1>
    <ul>
      <li> Elements of the vector are stored contiguously in memory. Unlike arrays, the size of the vector is dynamic. </li>
      <li> Vector internally uses dynamic memory buffers to store the elements. Instead of allocating new memory every time a 
           new element is added, vector allocates additional memory and copies data to new location. </li>
      <li> Emplace takes arguments necessary to construct an object in place, whereas insert takes reference to an object. 
           The advantage of emplace is, it does in-place insertion and avoids an unnecessary copy of object </li>
      <li> Note: N is the size of the container; n is the number of elements; m is the number of elements to move after deleting last element; 
            r is the number of elements inserted/deleted.  </li>
    </ul>
    
    <table>
      <!--Head of the table -->
      <thead> 
        <tr> 
          <th scope="col"> Type </th> 
          <th scope="col"> Format </th>
          <th scope="col"> Description </th> 
          <th scope="col"> Complexity </th> 
        </tr> 
      </thead>
      <tbody>
        <!--Constructors -->
        <tr> 
          <th rowspan=6 scope="row"> Constructors </th> 
          <td> vector&ltT&gt v </td>
          <td> Create a vector, v, of type T with zero elements </td> 
          <td> O(1) </td>
        </tr>
        <tr>
          <td> vector&ltT&gt v(n) </td>
          <td> Create a vector, v, of type T with n elements </td>
          <td> O(n) </td>
        </tr>
        <tr>
          <td> vector&ltT&gt v(n, val) </td>
          <td> Create and initialize n elements of vector, v, of type T with value val </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> vector&ltT&gt v(begin, end)</td> 
          <td> Create and copy the range of elements to vector v  </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> vector&ltT&gt v(v2) </td>
          <td> Initialize the vector v with elements of vector v2 </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> vector&ltT&gt v = move(vector&ltT&gt v2) </td>
          <td> Move the elements of vector v2 to vector v. v2 is empty after this operation. </td>
          <td> O(1) (when both allocs are same) </td>
        </tr>
        
        <!--Iterators -->
        <tr> 
          <th rowspan=8 scope="row"> Iterators </th> 
          <td> v.begin() </td>
          <td> Return iterator to beginning of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.end() </td>
          <td> Return iterator to end of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.rbegin() </td>
          <td> Return reverse iterator to reverse beginning (i.e. end) of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.rend() </td>
          <td> Return reverse iterator to reverse end (i.e. beginning) of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.cbegin() </td>
          <td> Return constant iterator to beginning of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.cend() </td>
          <td> Return constant iterator to end of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.crbegin() </td>
          <td> Return reverse constant iterator to reverse beginning of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.crend() </td>
          <td> Return reverse constant iterator to reverse end of the vector </td>
          <td> O(1) </td>
        </tr>
        
        <!--Capacity -->
        <tr> 
          <th rowspan=7 scope="row"> Capacity</th> 
          <td> v.size() </td>
          <td> Return the number of elements in the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.max_size() </td>
          <td> Return the maximum possible size that the container can reach due to known system or library implementation limitations </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.capacity() </td>
          <td> Return the size of currently allocated storage space i.e. size of the container </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.empty() </td>
          <td> Test whether vector is empty or not </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.reserve(n) </td>
          <td> Request a change in capacity to at least n elements </td>
          <td> O(n) at most  </td>
        </tr>
        <tr> 
          <td> v.resize(n) </td>
          <td> Resize the container to hold exactly n elements </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> v.shrink_to_fit() </td>
          <td> Request to free the unused memory </td>
          <td> O(N) at most </td>
        </tr>
        
        <!--Accessing elements -->
        <tr> 
          <th rowspan=5 scope="row"> Element Access</th>  
          <td> v[i] </td>
          <td> Access the i<sup>th</sup> element of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.at(i) </td>
          <td> Access the i<sup>th</sup> element of the array (automatically checks the boundaries) </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.front() </td>
          <td> Access the first element of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.back() </td>
          <td> Access the last element of the vector </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.data() </td>
          <td> Return pointer to the first element in the internal array used by the vector </td>
          <td> O(1) </td>
        </tr>
        
        <!--Modifiers -->
        <tr> 
          <th rowspan=15 scope="row"> Modifiers</th> 
          <td> v.push_back(value) </td>
          <td> Add the element to the end </td>
          <td> O(1) (amortized) </td>
        </tr>
        <tr> 
          <td> v.pop_back() </td>
          <td> Remove the last element </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.erase(iterator) </td>
          <td> Erase an element at the position pointed by the iterator </td>
          <td> O(m) </td>
        </tr>
        <tr> 
          <td> v.erase(begin, end) </td>
          <td> Erase all the elements within the range [begin,end) </td>
          <td> O(r+m) </td>
        </tr>
        <tr> 
          <td> v.insert(iterator, value) </td>
          <td> Insert an element before the position pointed by the iterator </td>
          <td> O(m) </td>
        </tr>
        <tr> 
          <td> v.insert(iterator, r, value)  </td>
          <td> Insert r elements before the position pointed by the iterator and initialize with value </td>
          <td> O(r+m) </td>
        </tr>
        <tr> 
          <td> v.insert(iterator, begin, end) </td>
          <td> Insert the range of elements before the position pointed by the iterator </td>
          <td> O(r+m)+O(log(n)) if iterator is not forward type </td>
        </tr>
        <tr> 
          <td> v.insert(iterator, initializer list) </td>
          <td> Insert the elements from another list before the position pointed by the iterator e.g., v.insert(iterator, {1,2,3})</td>
          <td> O(r+m)+O(log(n)) if iterator is not forward type </td>
        </tr>
        <tr> 
          <td> v.swap(vector&ltT&gt v2) </td>
          <td> Swap the elements of vector v and v2 </td>
          <td> O(1) </td>
        </tr>
        <tr> 
          <td> v.clear() </td>
          <td> Delete all the elements of the vector </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> v.assign(begin, end) </td>
          <td> Assign new values to the vector and resize accordingly  </td>
          <td> O(r+n)+O(log(n)) if iterator is not forward type </td>
        </tr>
        <tr> 
          <td> v.assign(n, val) </td>
          <td> Assign new value and resize the vector size to n </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> v.assign(initializer list) </td>
          <td> Assign n new values from another list e.g., v.assign({1,2,3}) </td>
          <td> O(n) </td>
        </tr>
        <tr> 
          <td> v.emplace(iterator, arguments) </td>
          <td> Construct and insert a new element at a position given by the iterator </td>
          <td> O(m) </td>
        </tr>
        <tr> 
          <td> v.emplace_back(arguments) </td>
          <td> Construct and insert a new element at the end of the vector </td>
          <td> O(1) amortized </td>
        </tr>
      </tbody> <!--End of the body -->
    </table> <!--End of the table -->
    
    <!-- Forward list -->
    <h1> <a name="forwardlist"> </a> std::forward_list </h1>
    <ul>
      <li> Forward list in C++ are implemented as a singly linked list. In singly linked list, elements are not stored consecutively in memory 
          rather each element includes a pointer which points to the location of next element. Insert and erase operations for single element in 
          forward list takes constant time since the pointer to the inserting and deleting position is available. </li>
      <li> Note: n is the number of elements in the forward_list; r is the number of elements inserted/deleted/transferred; m is the number of elements 
          in second forward_list </li>
    </ul>
    <table>
      <!--Head of the table -->
      <thead> 
        <tr> 
          <th scope="col"> Type </th> 
          <th scope="col"> Format </th>
          <th scope="col"> Description </th> 
          <th scope="col"> Complexity </th> 
        </tr> 
      </thead>
      <tbody>
        <!--Constructors -->
        <tr> 
          <th rowspan=6 scope="row"> Constructors </th> 
          <td> forward_list&ltT&gt f	</td>
          <td> Create a forward_list, f, of type T with zero elements	</td>
          <td> O(1) </td>
        </tr>
        <tr>
          <td> forward_list&ltT&gt f(n)	</td>
          <td> Create a forward_list, f, of type T with n elements	</td>
          <td> O(n) </td>
        </tr>
        <tr>
          <td> forward_list&ltT&gt f(n, val)	</td>
          <td> Create and initialize n elements of type T with value val	</td>
          <td> O(n) </td>
        </tr>
        <tr>
          <td> forward_list&ltT&gt f(begin, end)	</td>
          <td> Create and copy the range of elements to forward_list f 	</td>
          <td> O(n) </td>
        </tr>
        <tr>
          <td> forward_list&ltT&gt f(f2)	</td>
          <td> Initializes forward_list f with elements of forward_list f2	</td>
          <td> O(n) </td>
        </tr>
        <tr>
          <td> forward_list&ltT&gt f = move(forward_list&ltT&gt f2)	</td>
          <td> Move the elements of forward_list f2 to forward_list f. f2 is empty after this operation.	</td>
          <td> O(1) </td>
        </tr>
        
        <!--Iterators -->
        <tr> 
          <th rowspan=6 scope="row"> Iterators </th> 
        	<td> f.before_begin()	</td>
        	<td> Return iterator to before the first element of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.begin()	</td>
        	<td> Return iterator to beginning of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.end()	</td>
        	<td> Return iterator to end of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.cbefore_begin()	</td>
        	<td> Return constant iterator to before the first element of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.cbegin()	</td>
        	<td> Return constant iterator to beginning of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.cend()	</td>
        	<td> Return constant iterator to end of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        
        <!--Capacity -->
        <tr> 
          <th rowspan=2 scope="row"> Capacity</th> 
        	<td> f.max_size()	</td>
        	<td> Return the maximum possible size that the container can reach due to known system or library implementation limitations	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.empty()	</td>
        	<td> Test whether forward_list is empty or not	</td>
        	<td> O(1) </td>
        </tr>
        
        <!--Accessing elements -->
        <tr> 
          <th rowspan=1 scope="row"> Element Access</th>  
        	<td> f.front()	</td>
        	<td> Return reference to the first element of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        
        <!--Modifiers -->
        <tr> 
          <th rowspan=17 scope="row"> Modifiers</th> 
        	<td> f.push_front(value)	</td>
        	<td> Insert the element to the beginning of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.pop_front()	</td>
        	<td> Delete the first element of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.clear()	</td>
        	<td> Delete all the elements of the forward_list	</td>
        	<td> O(n) </td>
        </tr>
        <tr>
        	<td> f.erase_after(iterator)	</td>
        	<td> Erase an element at the position pointed by the iterator	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.erase_after(begin, end)	</td>
        	<td> Erase all the elements within the range (begin, end)	</td>
        	<td> O(r) </td>
        </tr>
        <tr>
        	<td> f.insert_after(iterator, value)	</td>
        	<td> Insert an element before the position pointed by the iterator	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.insert_after(iterator, r, value)	</td>
        	<td> Insert r elements before the position pointed by the iterator and initialize with value	</td>
        	<td> O(r) </td>
        </tr>
        <tr>
        	<td> f.insert_after(iterator, begin, end)	</td>
        	<td> Insert the range of elements before the position pointed by the iterator	</td>
        	<td> O(r) </td>
        </tr>
        <tr>
        	<td> f.insert_after(iterator, initializer list)	</td>
        	<td> Insert the elements from another list before the position pointed by the iterator e.g., f.insert(iterator, {1,2,3}	</td>
        	<td> O(r) </td>
        </tr>
        <tr>
        	<td> f.assign(begin, end)	</td>
        	<td> Assign new values to the forward_list and resize accordingly	</td>
        	<td> O(r+n) </td>
        </tr>
        <tr>
        	<td> f.assign(r, val)	</td>
        	<td> Assign new value and resize the size to r	</td>
        	<td> O(r+n) </td>
        </tr>
        <tr>
        	<td> f.assign(initializer list)	</td>
        	<td> Assign r new values from another list e.g., f.assign({1,2,3})	</td>
        	<td> O(r+n) </td>
        </tr>
        <tr>
        	<td> f.emplace_front(arguments)	</td>
        	<td> Construct and insert a new element at the beginning of the forward_list	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.emplace_after(position, arguments)	</td>
        	<td> Construct and insert a new element after the position in the forward_list	</td>
        	<td> O(1)  </td>
        </tr>
        <tr>
        	<td> f.resize(r)	</td>
        	<td> If r is less than the size of forward_list, list is trimmed otherwise extended	</td>
        	<td> O(r)+O(n) </td>
        </tr>
        <tr>
        	<td> f.resize(r, val)	</td>
        	<td> If r is less than the size of forward_list, list is trimmed otherwise extended and initialized extended elements with val	</td>
        	<td> O(r)+O(n) </td>
        </tr>
        <tr>
        	<td> f.swap(forward_list&ltT&gt f2)	</td>
        	<td> Swap the elements of forward_list f and f2	</td>
        	<td> O(1) </td>
        </tr>
        
        <!--Operations -->
        <tr> 
          <th rowspan=15 scope="row"> Operations</th> 
        	<td> f.splice_after(position, f2)	</td>
        	<td> Transfer elements from another forward_list f2 to before the specified position	</td>
        	<td> O(r) </td>
        </tr>
        <tr>
        	<td> f.splice_after(position, f2, begin)	</td>
        	<td> Transfer an element pointed by begin from forward_list f2 to before the specified position of f	</td>
        	<td> O(1) </td>
        </tr>
        <tr>
        	<td> f.splice_after(position, f2, begin, end)	</td>
        	<td> Transfer elements in range (begin, end] from forward_list f2 to before the specified position of f	</td>
        	<td> O(r) </td>
        </tr>
        <tr>
        	<td> f.remove(val)	</td>
        	<td> Remove all the elements which matches with val	</td>
        	<td> O(n) </td>
        </tr>
        <tr>
        	<td> f.remove_if(condition)	</td>
        	<td> Remove elements which fulfill the condition	</td>
        	<td> O(n) </td>
        </tr>
        <tr>
        	<td> f.unique()	</td>
        	<td> Remove all the duplicate values	</td>
        	<td> O(n) </td>
        </tr>
        <tr>
        	<td> f.unique(binary_predicate)	</td>
        	<td> Remove all the duplicate values depending on the specified function	</td>
        	<td> O(n) </td>
        </tr>
        <tr>
        	<td> f.merge(f2)	</td>
        	<td> merge the sorted lists	</td>
        	<td> O(m+n) </td>
        </tr>
        <tr>
        	<td> f.merge(f2, compare)	</td>
        	<td> merge the sorted lists based on the compare condition	</td>
        	<td> O(m+n) </td>
        </tr>
        <tr>
        	<td> f.sort()	</td>
        	<td> Sort elements of the list	</td>
        	<td> O(n log n) </td>
        </tr>
        <tr>
        	<td> f.sort(compare)	</td>
        	<td> Sort elements of the list based on the compare condition	</td>
        	<td> O(n log n) </td>
        </tr>
        <tr>
        	<td> f.reverse()	</td>
        	<td> Reverse the order of elements	</td>
        	<td> O(n) </td>
        </tr>
      </tbody> <!--End of the body -->
    </table> <!--End of the table -->
    
    <!-- List -->
    <h1> <a name="list"> </a> std::list </h1>
    <ul>
      <li> List in C++ are implemented as doubly linked list. In doubly linked list, elements are not stored consecutively 
           in memory rather each element includes pointers which points to the previous and next element. Insert and erase 
           operations for a single element in list takes constant time since the pointer to the inserting and deleting position is available. </li>
      <li> Note: n is the number of elements in the list; r is the number of elements inserted/deleted/transferred; m is the number 
          of elements in second </li>
    </ul>
    <table>
      <!--Head of the table -->
      <thead> 
        <tr> 
          <th scope="col"> Type </th> 
          <th scope="col"> Format </th>
          <th scope="col"> Description </th> 
          <th scope="col"> Complexity </th> 
        </tr> 
      </thead>
      <tbody>
        <!--Constructors -->
        <tr> 
          <th rowspan=6 scope="row"> Constructors </th> 
          <td> list&ltT&gtl	</td>
          <td> Create a list, l, of type T with zero elements	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> list&ltT&gtl(n)	</td>
          <td> Create a list, l, of type T with n elements	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> list&ltT&gtl(n, val)	</td>
          <td> Create and initialize n elements of type T with value val	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> list&ltT&gtl(begin, end)	</td>
          <td> Create and copy the range of elements to list l 	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> list&ltT&gtl(l2)	</td>
          <td> Initialize list f with elements of list l2	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> list&ltT&gtl = move(list&ltT&gtl2)	</td>
          <td> Move the elements of list l2 to list l. l2 is empty after this operation.	</td>
          <td> O(1)</td>
        </tr>
        
        <!--Iterators -->
        <tr> 
          <th rowspan=8 scope="row"> Iterators </th> 
          <td> l.begin()	</td>
          <td> Return iterator to beginning of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.end()	</td>
          <td> Return iterator to end of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.rbegin()	</td>
          <td> Return reverse iterator to reverse beginning (i.e. end) of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.rend()	</td>
          <td> Return reverse iterator to reverse end (i.e. beginning) of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.cbegin()	</td>
          <td> Return constant iterator to beginning of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.cend()	</td>
          <td> Return constant iterator to end of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.crbegin()	</td>
          <td> Return reverse constant iterator to reverse beginning of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.crend()	</td>
          <td> Return reverse constant iterator to reverse end of the list	</td>
          <td> O(1)</td>
        </tr>
        
        <!--Capacity -->
        <tr> 
          <th rowspan=3 scope="row"> Capacity</th> 
          <td> l.max_size()	</td>
          <td> Return the maximum possible size that the container can reach due to known system or library implementation limitations	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.size()	</td>
          <td> Return the number of elements in the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.empty()	</td>
          <td> Test whether list is empty or not	</td>
          <td> O(1)</td>
        </tr>
        
        <!--Accessing elements -->
        <tr> 
          <th rowspan=2 scope="row"> Element Access</th>  
        	<td> l.front()	</td>
          <td> Return reference to the first element of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.back()	</td>
          <td> Return reference to the last element of the list	</td>
          <td> O(1)</td>
        </tr>
        
        <!--Modifiers -->
        <tr> 
          <th rowspan=20 scope="row"> Modifiers</th> 
          <td> l.push_front(value)	</td>
          <td> Insert the element to the beginning of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.pop_front()	</td>
          <td> Delete the first element of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.push_back(value)	</td>
          <td> Insert the element to the end of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.pop_back()	</td>
          <td> Delete the last element of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.erase(iterator)	</td>
          <td> Erase an element at the position pointed by the iterator	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.erase(begin, end)	</td>
          <td> Erase all the elements within the range [begin, end)	</td>
          <td> O(r)</td>
        </tr>
        <tr>
          <td> l.insert(iterator, value)	</td>
          <td> Insert an element before the position pointed by the iterator	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.insert(iterator, r, value)	</td>
          <td> Insert r elements before the position pointed by the iterator and initialize with value	</td>
          <td> O(r)</td>
        </tr>
        <tr>
          <td> l.insert(iterator, begin, end)	</td>
          <td> Insert the range of elements before the position pointed by the iterator	</td>
          <td> O(r)</td>
        </tr>
        <tr>
          <td> l.insert(iterator, initializer list)	</td>
          <td> Insert the elements from another list before the position pointed by the iterator e.g., l.insert(iterator, {1,2,3}	</td>
          <td> O(r)</td>
        </tr>
        <tr>
          <td> l.resize(r)	</td>
          <td> If r is less than the size of list, list is trimmed otherwise extended	</td>
          <td> O(r)+O(n)</td>
        </tr>
        <tr>
          <td> l.resize(r, val)	</td>
          <td> If r is less than the size of list, list is trimmed otherwise extended and initialized extended elements with val	</td>
          <td> O(r)+O(n)</td>
        </tr>
        <tr>
          <td> l.swap(list&ltT&gtl2)	</td>
          <td> Swap the elements of list l and l2	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.clear()	</td>
          <td> Delete all the elements of the list	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> l.assign(begin, end)	</td>
          <td> Assign new values to the list and resize accordingly	</td>
          <td> O(r+n)</td>
        </tr>
        <tr>
          <td> l.assign(r, val)	</td>
          <td> Assign new value and resize the size to r	</td>
          <td> O(r+n)</td>
        </tr>
        <tr>
          <td> l.assign(initializer list)	</td>
          <td> Assign r new values from another list e.g., l.assign({1,2,3})	</td>
          <td> O(r+n)</td>
        </tr>
        <tr>
          <td> l.emplace_front(arguments)	</td>
          <td> Construct and insert a new element at the beginning of the list	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.emplace_back(arguments)	</td>
          <td> Construct and insert a new element at the end of the list	</td>
          <td> O(1) </td>
        </tr>
        <tr>
          <td> l.emplace(position, arguments)	</td>
          <td> Construct and insert a new element at the given position of the list	</td>
          <td> O(1) </td>
        </tr>
        
        <!--Operations -->
        <tr> 
          <th rowspan=15 scope="row"> Operations</th> 
        	<td> l.splice_after(position, l2)	</td>
          <td> Transfer elements from another list l2 to before the specified position	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.splice_after(position, l2, begin)	</td>
          <td> Transfer an element pointed by begin from list l2 to before the specified position of f	</td>
          <td> O(1)</td>
        </tr>
        <tr>
          <td> l.splice_after(position, l2, begin, end)	</td>
          <td> Transfer elements in range (begin, end] from list l2 to before the specified position of f	</td>
          <td> O(r)</td>
        </tr>
        <tr>
          <td> l.remove(val)	</td>
          <td> Remove all the elements which matches with val	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> l.remove_if(condition)	</td>
          <td> Remove elements which fulfill the condition	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> l.unique()	</td>
          <td> Remove all the duplicate values	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> l.unique(binary_predicate)	</td>
          <td> Remove all the duplicate values depending on the specified function	</td>
          <td> O(n)</td>
        </tr>
        <tr>
          <td> l.merge(l2)	</td>
          <td> Merge the sorted lists	</td>
          <td> O(m+n)</td>
        </tr>
        <tr>
          <td> l.merge(l2, compare)	</td>
          <td> Merge the sorted lists based on the compare condition	</td>
          <td> O(m+n)</td>
        </tr>
        <tr>
          <td> l.sort()	</td>
          <td> Sort elements of the list	</td>
          <td> O(n log n)</td>
        </tr>
        <tr>
          <td> l.sort(compare)	</td>
          <td> Sort elements of the list based on the compare condition	</td>
          <td> O(n log n)</td>
        </tr>
        <tr>
          <td> l.reverse()	</td>
          <td> Reverse the order of elements	</td>
          <td> O(n)</td>
        </tr>
      </tbody> <!--End of the body -->
    </table> <!--End of the table -->
    
  </body>
</html>
